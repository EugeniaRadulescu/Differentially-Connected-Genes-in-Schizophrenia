
###### Load the expression data and module colors ##########

load("/home/edata/.../.../Consensus_tree_modulesColors_expr_CTRL_SCZ_10312022.RData")
Genes<-colnames(multiExpr[["B1"]][["data"]])


# Load required libraries
# NOTE: Make sure the following libraries are installed and loaded
# install.packages("data.table")
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("clusterProfiler")
# BiocManager::install("org.Hs.eg.db")
# BiocManager::install("DOSE")

library(data.table)
library(clusterProfiler)
library(org.Hs.eg.db)

#' @title A function to perform comprehensive GO enrichment analysis on WGCNA modules.
#'
#' @description This function takes gene symbols and their corresponding module colors
#' and performs a series of GO enrichment analyses (enrichGO, simplify). 
#'
#' @param genes A vector of gene symbols (e.g., rownames(datExpr_minusOutliers)).
#' @param module_colors A vector of module colors for each gene (e.g., unmergedColors_SCZ).
#'
#' @return A list of simplified enrichment results.
#'
#' @examples
#' # First, ensure you have your gene and module color vectors loaded
#' # For example:
#' # Genes <- rownames(datExpr_minusOutliers)
#' # unmergedColors_SCZ_DLPFC <- ...
#' # enrichment_results <- run_enrichment_steps(Genes, unmergedColors_SCZ_DLPFC)
#' # Now you can run the next function with these results.

run_enrichment_steps <- function(genes, module_colors) {
  
  cat("Step 1: Preparing data for analysis...\n")
  DF <- data.frame(Genes = genes, ModuleColors = module_colors)
  DT <- setDT(DF)
  DT <- DT[order(DT$ModuleColors), ]
  
  modules_list <- split(DT, by = "ModuleColors")
  
  genes_by_module <- lapply(modules_list, function(x) as.vector(x$Genes))
  
  nsets <- length(genes_by_module)
  cat("Found", nsets, "modules for analysis.\n")
  
  # Step 2: Perform GO enrichment analysis with enrichGO
  cat("Step 2: Running enrichGO for each module...\n")
  ego <- lapply(genes_by_module, function(g) {
    enrichGO(gene = g,
             universe = genes,
             OrgDb = org.Hs.eg.db,
             ont = "BP",
             keyType = 'SYMBOL',
             minGSSize = 100,
             maxGSSize = 5000,
             pAdjustMethod = "BH",
             pvalueCutoff = 0.001,
             qvalueCutoff = 0.001,
             pool = FALSE,
             readable = FALSE)
  })
  
  # Step 3: Simplify redundant GO terms
  cat("Step 3: Simplifying GO terms...\n")
  ego2 <- lapply(ego, function(e) {
    if (is.null(e) || nrow(e@result) == 0) return(NULL)
    clusterProfiler::simplify(e,
                              cutoff = 0.7,
                              by = "p.adjust",
                              select_fun = min,
                              measure = "Wang")
  })
  
  cat("Enrichment steps complete. Returning results...\n")
  # Return the simplified results directly
  return(ego2)
}

enrichment_results <- run_enrichment_steps(Genes, unmergedColors_SCZ)

run_sim_and_viz_steps <- function(ego2_list, condition, region, min_gene_count = 10) {
  # NOTE: Make sure the rrvgo library is installed and loaded
  # BiocManager::install("rrvgo")
  
  library(rrvgo)
  
  # Step 5: Combine results into a single data frame
  cat("Step 5: Combining results into a single data frame...\n")
  ego2_df_list <- lapply(ego2_list, function(x) {
    if (is.null(x) || nrow(x@result) == 0) return(NULL)
    as.data.frame(x)
  })
  
  # Remove any null or empty elements from the list before combining
  ego2_df_list <- ego2_df_list[!sapply(ego2_df_list, is.null)]
  
  if (length(ego2_df_list) < 1) {
    warning("No modules with significant GO terms found.")
    return(NULL)
  }
  
  ego2_df <- do.call(rbind, ego2_df_list)
  
  # NEW: Filter out GO terms with a low gene count
  cat("Filtering GO terms with gene count less than", min_gene_count, "...\n")
  ego2_df <- ego2_df[ego2_df$Count >= min_gene_count, ]
  
  # Check again if there are enough modules left for rrvgo analysis
  if (nrow(ego2_df) < 2) {
    warning("Not enough GO terms for rrvgo analysis (less than 2).")
    return(NULL)
  }
  
  # Step 6: Create the 'Module' variable
  cat("Step 6: Creating 'Module' variable...\n")
  # Use the Module names from the original list, but only for the terms that remain
  original_module_names <- names(ego2_df_list)
  
  # Create a vector of module names that matches the combined data frame
  module_vector <- c()
  for (i in seq_along(ego2_df_list)) {
    current_df <- ego2_df_list[[i]]
    # Filter for terms that passed the gene count threshold
    filtered_rows <- current_df[current_df$Count >= min_gene_count, ]
    module_vector <- c(module_vector, rep(original_module_names[i], nrow(filtered_rows)))
  }
  
  ego2_df$Module <- module_vector
  
  # Step 7: Perform semantic similarity analysis with rrvgo
  cat("Step 7: Running semantic similarity analysis...\n")
  simMatrix <- rrvgo::calculateSimMatrix(ego2_df$ID,
                                         orgdb = "org.Hs.eg.db",
                                         ont = "BP",
                                         method = "Wang")
  
  reducedTerms <- rrvgo::reduceSimMatrix(simMatrix,
                                         threshold = 0.7,
                                         orgdb = "org.Hs.eg.db")
  
  # Step 8: Return the final results
  results <- list(
    combined_df = ego2_df,
    simMatrix = simMatrix,
    reducedTerms = reducedTerms
  )
  
  cat("Analysis for", region, condition, "complete.\n")
  return(results)
}

final_results <- run_sim_and_viz_steps(enrichment_results, "SCZ", "DLPFC", min_gene_count = 10)


heatmapPlot(final_results$simMatrix,
            final_results$reducedTerms,
            annotateParent=TRUE,
            annotationLabel="parentTerm",
            fontsize=6)

treemapPlot(final_results$reducedTerms)

scatterPlot(final_results$simMatrix,final_results$reducedTerms)
