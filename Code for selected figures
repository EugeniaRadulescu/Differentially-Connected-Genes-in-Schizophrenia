
##### Supplementary figure S1 ########

analyze_WGCNA_regions <- function(region_name) {
  
  # Set the base directory for the data files.
  base_path <- "/home/edata/.../.../"
  
  # Construct the full path to the data file.
  file_path <- file.path(base_path, "Consensus_tree_modulesColors_expr_CTRL_SCZ_10312022.RData")
  
  # Load the data from the specified file path.
  # This assumes the file contains objects like unmergedLabels_CTRL, unmergedLabels_SCZ, etc.
  load(file_path)
  
  # Re-label the consensus modules to match the CTRL-only analysis.
  modLabCTRL_SCZ <- WGCNA::matchLabels(unmergedLabels_CTRL, unmergedLabels_SCZ)
  moduleColorsCTRL_SCZ <- WGCNA::labels2colors(modLabCTRL_SCZ)
  
  # Create a data frame of module colors for plotting dendrograms.
  datColors <- data.frame(moduleColorsCTRL_SCZ, unmergedColors_SCZ, unmergedColors_CTRL)
  
  # Calculate module overlap tables.
  ovTable <- WGCNA::overlapTable(moduleColorsCTRL_SCZ, unmergedColors_SCZ)
  ovTable1 <- WGCNA::overlapTable(moduleColorsCTRL_SCZ, unmergedColors_CTRL)
  
  # Prepare text matrices for the heatmaps.
  textMatrix <- paste(signif(ovTable$pTable, 2))
  dim(textMatrix) <- dim(ovTable$pTable)
  
  textMatrix1 <- paste(signif(ovTable1$pTable, 2))
  dim(textMatrix1) <- dim(ovTable1$pTable)
  
  # Create plots.
  # Set up the plotting window and margins for the heatmaps.
  sizeGrWindow(12, 10)
  par(mar = c(6, 8.5, 3, 3))
  
  # Plot the first heatmap for matched labels vs. SCZ modules.
  WGCNA::labeledHeatmap(Matrix = ovTable$pTable,
                 xLabels = colnames(ovTable$pTable),
                 xSymbols = colnames(ovTable$pTable),
                 yLabels = rownames(ovTable$pTable),
                 ySymbols = rownames(ovTable$pTable),
                 colorLabels = FALSE,
                 colors = greenWhiteRed(50),
                 textMatrix = textMatrix,
                 setStdMargins = FALSE,
                 cex.text = 0.5,
                 zlim = c(-1, 1),
                 main = paste("pValues for matched labels SCZ", region_name))

  # Plot the second heatmap for matched labels vs. CTRL modules.
  WGCNA::labeledHeatmap(Matrix = ovTable1$pTable,
                 xLabels = colnames(ovTable1$pTable),
                 xSymbols = colnames(ovTable1$pTable),
                 yLabels = rownames(ovTable1$pTable),
                 ySymbols = rownames(ovTable1$pTable),
                 colorLabels = FALSE,
                 colors = greenWhiteRed(50),
                 textMatrix = textMatrix1,
                 setStdMargins = FALSE,
                 cex.text = 0.5,
                 zlim = c(-1, 1),
                 main = paste("pValues for matched labels CTRL", region_name))
                 
  # Plot dendrograms with module colors.
  plotDendroAndColors(consTree_CTRL, datColors, c("matched modules", "SCZ modules", "CTRL modules"),
                      dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,
                      main = paste("CTRL gene dendrogram and module colors for", region_name))
  
  plotDendroAndColors(consTree_SCZ, datColors, c("matched modules", "SCZ modules", "CTRL modules"),
                      dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,
                      main = paste("SCZ gene dendrogram and module colors for", region_name))
  
  # Prepare the data frame for saving.
  Symbol <- colnames(multiExpr[[1]]$data)
  datColors$Symbol <- Symbol
  datColors <- datColors[order(datColors$moduleColorsCTRL_SCZ, datColors$unmergedColors_SCZ, datColors$unmergedColors_CTRL), ]
  
  # Save the relevant objects to a new RData file.
  output_filename <- paste0("Matched_color_modules_CTRL_SCZ_forClProfiler_", format(Sys.Date(), "%m%d%Y"), ".RData")
  save(datColors, ovTable, ovTable1, textMatrix, textMatrix1, Symbol, file = output_filename)
  
  # Print confirmation message.
  cat("Analysis complete for", region_name, ". Results saved to", output_filename, "\n")
  
  # Return the ordered data frame if needed for further use.
  invisible(datColors)
}

# Apply the function for each brain region:
# Example for "DLPFC"
analyze_WGCNA_regions("DLPFC")

###### Figure 2 ########

# Load data tables that store differences and absolute differences for network metrics
# Function to format data for the scatter-plot matrix

library(data.table)

#' @title A function to combine multiple data.tables into a single long-format data.table.
#'
#' @description This function takes a named list of data.tables, adds a new 'Region'
#' column based on the list's names, standardizes the column names by removing the suffix,
#' and then combines them into one long-format data.table.
#'
#' @param dt_list A named list of data.tables to be combined (e.g., list(DLPFC = DLPFC_data, ...)).
#' @param suffixes A vector of suffixes to be removed from the column names (e.g., c("_DLPFC", "_Hippo")).
#'
#' @return A single long-format data.table with an added 'Region' column.
#'
#' @examples
#' # Assume you have created your three data.tables: DLPFC_data, Hippo_data, Caudate_data
#' # Combine them into a single data.table
#'
#' combined_dt <- combine_regions(
#'   dt_list = list(DLPFC = DLPFC_data, Hippo = Hippo_data, Caudate = Caudate_data),
#'   suffixes = c("_DLPFC", "_Hippo", "_Caudate")
#' )

combine_regions <- function(dt_list, suffixes) {
  # Add a 'Region' column to each data.table
  for (region_name in names(dt_list)) {
    dt_list[[region_name]][, Region := region_name]
  }
  
  # Get the common base column names
  base_cols <- gsub(suffixes[1], "", names(dt_list[[1]]))
  
  # Standardize column names for all data.tables
  for (i in seq_along(dt_list)) {
    setnames(dt_list[[i]], old = names(dt_list[[i]])[1:length(base_cols)], new = base_cols)
  }
  
  # Combine the data.tables into one long format
  combined_dt <- rbindlist(dt_list)
  
  return(combined_dt)
}


# Create a named list of your data tables
region_list <- list(DLPFC = DLPFC_data, Hippo = Hippo_data, Caudate = Caudate_data)

# Specify the suffixes to remove
region_suffixes <- c("_DLPFC", "_Hippo", "_Caudate")

# Call the function to combine them
final_combined_dt <- combine_regions(dt_list = region_list, suffixes = region_suffixes)

# View the final data.table
print(final_combined_dt)

alldata_long<-final_combined_dt[,c(3,6,9,11)]

library(GGally)

GGally::ggpairs(alldata_long,upper = list(continuous = GGally::wrap("cor", method = "kendall")),
        aes(color = Region, alpha = 0.6)) 

p <- ggpairs(
  alldata_long,
  mapping = ggplot2::aes(color = Region, alpha = 0.4),
  upper = list(continuous = GGally::wrap("cor", method = "kendall")),
  lower = list(continuous = wrap("points", alpha = 0.4,"shape"=21)),
  title = "Brain regional correlations between absolute differences in network metrics"
)

p

for(i in 1:p$nrow) {
  for(j in 1:p$ncol){
    p[i,j] <- p[i,j] + 
      scale_fill_manual(values=c("green4", "darkorange3", "deepskyblue3")) +
      scale_color_manual(values=c("green4", "darkorange3", "deepskyblue3"))  
  }
}

p

###### For figure 3 paper final ###########

library(tidyr)
library(dplyr)
library(broom)
library(data.table)
library(readxl)

intramodular_conn_CTRL_and_SCZ <- read_excel("intramodular_conn_CTRL_and_SCZ.xlsx")
intraMod_con_refCTRL_modules_12272022 <- read_excel("Hippocampus/intraMod_con_refCTRL_modules_12272022.xlsx")
intraMod_con_refCTRL_modules_01092023 <- read_excel("Caudate/intraMod_con_refCTRL_modules_01092023.xlsx")

data<-intramodular_conn_CTRL_and_SCZ # DLPFC
data<-intraMod_con_refCTRL_modules_12272022 # Hippo
data<-intraMod_con_refCTRL_modules_01092023 # Caudate

library(data.table)

data<-setDT(data)
names(data)

calculate_metrics <- function(data, variable_name, region_name) {
  # Convert to data.table and prepare data
  data <- setDT(data)
  
  # Select the correct columns for the given variable
  ctrl_col <- paste0(variable_name, "_CTRL")
  scz_col <- paste0(variable_name, "_SCZ")
  
  if (!all(c(ctrl_col, scz_col) %in% names(data))) {
    stop("Input columns not found for the specified variable.")
  }
  
  data[, means := get(ctrl_col)]
  data[, diffs := get(ctrl_col) - get(scz_col)]
  data[, absDiffs := abs(diffs)]
  
  # Calculate the breaks to define outliers
  stats <- boxplot.stats(data$absDiffs)$stats
  iqr <- stats[4] - stats[2]
  outlier_threshold <- stats[4] + 1.5 * iqr
  
  # Add a 'is_outlier' column to classify outliers
  data[, is_outlier := absDiffs > outlier_threshold]
  
  # Add the region and variable names to the data table for plotting
  data[, region := region_name]
  data[, variable := variable_name]
  data[, breaks_value := outlier_threshold]
  
  return(data)
}


library(ggplot2)
library(MASS)
library(viridis)

generate_density_plot <- function(data) {
  # Create a density column for plotting
  get_density <- function(x, y, ...) {
    dens <- MASS::kde2d(x, y, ...)
    ix <- findInterval(x, dens$x)
    iy <- findInterval(y, dens$y)
    ii <- cbind(ix, iy)
    return(dens$z[ii])
  }
  
  # Calculate density for all points
  data[, density := get_density(data$means, data$absDiffs, n = 100)]
  
  # Plot the data
  p <- ggplot(data) +
    # Plot non-outliers first, colored by density
    geom_point(data = data[is_outlier == FALSE], aes(x = means, y = absDiffs, color = density),
               size = 2, shape = 21, alpha = 0.6) +
    scale_color_viridis() +
    # Plot outliers on top, in a static color
    geom_point(data = data[is_outlier == TRUE], aes(x = means, y = absDiffs),
               color = "grey40", size = 2, shape = 21, alpha = 0.6) +
    scale_x_continuous(expand = expansion(mult = c(0.1, 0.1))) +
    scale_y_continuous(expand = expansion(mult = c(0.1, 0.1))) +
    ylab(paste0("Absolute Difference of ", unique(data$variable), "\nCTRL vs. SCZ")) +
    xlab(paste0(unique(data$variable), " CTRL")) +
    geom_hline(yintercept = 0, color = "black") +
    geom_hline(yintercept = unique(data$breaks_value), color = "black", linetype = "dashed") +
    annotate("text",
             x = max(data$means, na.rm = TRUE) * 1.05,
             y = unique(data$breaks_value),
             label = round(unique(data$breaks_value), digits = 4),
             size = 6, vjust = -0.5) +
    theme_bw(base_size = 16) +
    theme(
      axis.title = element_text(size = 18, face = "bold", color = "black"),
      axis.text = element_text(size = 14),
      plot.title = element_text(family = "", face = "bold", color = "black", size = 24),
      legend.position = "none"
    )
  
  return(p)
}


# Load your data
library(readxl)
intramodular_conn_CTRL_and_SCZ <- read_excel("intramodular_conn_CTRL_and_SCZ.xlsx")
intraMod_con_refCTRL_modules_12272022 <- read_excel("Hippo/intraMod_con_refCTRL_modules_12272022.xlsx")
intraMod_con_refCTRL_modules_01092023 <- read_excel("Caudate/intraMod_con_refCTRL_modules_01092023.xlsx")

# Process the DLPFC data for kTotal
dlpfc_kTotal_data <- calculate_metrics(
  data = intramodular_conn_CTRL_and_SCZ,
  variable_name = "kTotal",
  region_name = "DLPFC"
)

# Generate the plot
dlpfc_kTotal_plot <- generate_density_plot(dlpfc_kTotal_data)
print(dlpfc_kTotal_plot)

# Process the Hippo data for kIn
hippo_kIn_data <- calculate_metrics(
  data = intraMod_con_refCTRL_modules_12272022,
  variable_name = "kIn",
  region_name = "Hippo"
)

# Generate the plot
hippo_kIn_plot <- generate_density_plot(hippo_kIn_data)
print(hippo_kIn_plot)









