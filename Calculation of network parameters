
##### This is an essential part of the analysis #######
##### 1. Calculating the network parameters of interst #######

# Load the expression data and consensus tree & modules for the three regions:
# Reference modules: CTRL modules

load("/home/edata/.../.../Expression_data_for_rWGCNA_297samples_10202022.RData")
load("/home/edata/.../.../Consensus_tree_modulesColors_expr_CTRL_SCZ_10312022.RData")

load("/home/edata/.../.../Consensus_tree_modulesColors_CTRL_SCZ_12212022.RData")
load("/home/edata/.../.../Expression_data_for_rWGCNA_250samples_12152022.RData")

load("/home/edata/.../.../Expression_data_for_rWGCNA_349samples_12162022.RData")
load("/home/edata/.../.../Consensus_tree_modulesColors_Caudate_CTRL_SCZ_12232022.RData")

# Create adjacency matrices for CTRL and SCZ:

collectGarbage()

adj_CTRL<-adjacency(datExpr=datExpr_CTRL,type="signed",power=10, # 11 for Caudate, 14 for Hippo
                    corFnc = "bicor")
adj_SCZ<-adjacency(datExpr=datExpr_SCZ,type="signed",power=10,
                   corFnc = "bicor")
# save(adj_SCZ,file="adjacency_SCZ_03132024.RData")

# Calculate intramodular connectivity using as reference CTRL modules for all six networks
# This will give kIn and kTotal, but kTotal is not dependent on modules

# Scaled
intraMod_con_CTRL_scaled<-intramodularConnectivity(adj_CTRL,colors = unmergedColors_CTRL,scaleByMax = TRUE)
intraMod_con_SCZ<-intramodularConnectivity(adj_SCZ,colors = dynamicColors_CTRL,scaleByMax = TRUE)

# Unscaled:
intraMod_con_CTRL_ns<-intramodularConnectivity(adj_CTRL,colors = dynamicColors_CTRL,scaleByMax = FALSE)
intraMod_con_SCZ_ns<-intramodularConnectivity(adj_SCZ,colors = dynamicColors_CTRL,scaleByMax = FALSE)

intraMod_con_refCTRL_modules<-cbind(intraMod_con_CTRL_ns1,intraMod_con_SCZ_ns1)
Names<-c("kTotal_CTRL","KWithin_CTRL","kOut_CTRL","kDiff_CTRL","kTotal_SCZ","KWithin_SCZ","kOut_SCZ","kDiff_SCZ")
names(intraMod_con_refCTRL_modules)<-Names
# Of note, the adjustment of kIn by module size was done in Excel tables.

# Calculate clustering coefficient
# This is computationally demanding, it takes at least 12 hours.
clCoeff_CTRL<-clusterCoef(adj_CTRL) 
clCoeff_SCZ<-clusterCoef(adj_SCZ) 

##### Calculate differences and absolute differences in network metrics #########

library(GGally)
library(tidyr)
library(dplyr)
library(broom)
library(data.table)
library(readxl)

intramodular_conn_CTRL_and_SCZ <- read_excel("intramodular_conn_CTRL_and_SCZ.xlsx")
intraMod_con_refCTRL_modules_12272022 <- read_excel(".../intraMod_con_refCTRL_modules_12272022.xlsx")
intraMod_con_refCTRL_modules_01092023 <- read_excel(".../intraMod_con_refCTRL_modules_01092023.xlsx")


data1<-as.data.frame(cbind(intramodular_conn_CTRL_and_SCZ$kTotal_CTRL,intramodular_conn_CTRL_and_SCZ$kTotal_SCZ,
            intramodular_conn_CTRL_and_SCZ$kIn_CTRL,intramodular_conn_CTRL_and_SCZ$kIn_SCZ,
            intramodular_conn_CTRL_and_SCZ$C_CTRL,intramodular_conn_CTRL_and_SCZ$C_SCZ)) # DLPFC
data1$Symbol<-as.character(intramodular_conn_CTRL_and_SCZ$Symbol)

names(data1)<-c("kTotal_CTRL","kTotal_SCZ","kIn_CTRL","kIn_SCZ","C_CTRL","C_SCZ","Symbol")

# For Hippo
data2<-as.data.frame(cbind(intraMod_con_refCTRL_modules_12272022$kTotal_CTRL,intraMod_con_refCTRL_modules_12272022$kTotal_SCZ,
                           intraMod_con_refCTRL_modules_12272022$kIn_CTRL,intraMod_con_refCTRL_modules_12272022$kIn_SCZ,
                           intraMod_con_refCTRL_modules_12272022$C_CTRL,intraMod_con_refCTRL_modules_12272022$C_SCZ)) # Hippo
data2$Symbol<-as.character(intraMod_con_refCTRL_modules_12272022$Symbol)

names(data2)<-c("kTotal_CTRL","kTotal_SCZ","kIn_CTRL","kIn_SCZ","C_CTRL","C_SCZ","Symbol")

# For Caudate
data3<-as.data.frame(cbind(intraMod_con_refCTRL_modules_01092023$kTotal_CTRL,
                           intraMod_con_refCTRL_modules_01092023$kTotal_SCZ,intraMod_con_refCTRL_modules_01092023$kIn_CTRL,
                          intraMod_con_refCTRL_modules_01092023$kIn_SCZ,intraMod_con_refCTRL_modules_01092023$C_CTRL,
                          intraMod_con_refCTRL_modules_01092023$C_SCZ)) # Caudate
data3$Symbol<-as.character(intraMod_con_refCTRL_modules_01092023$Symbol)

names(data3)<-c("kTotal_CTRL","kTotal_SCZ","kIn_CTRL","kIn_SCZ","C_CTRL","C_SCZ","Symbol")


library(data.table)

#' @title A function to perform network metric calculations and rename columns
#'
#' @description This function takes a data.table and calculates means, differences,
#' and absolute differences for three pairs of variables (Cl, kIn, K). It then
#' selects the newly created columns and renames them by adding a specified suffix.
#'
#' @param data A data.table or data frame containing the variables to be used in the calculations.
#' @param suffix The suffix to add to the new variable names (e.g., "_DLPFC").
#'
#' @return A data.table containing only the renamed calculated variables.
#'
#' @examples
#' # Assume 'data' is your data.table with columns like C_CTRL, kIn_SCZ, etc.
#' # For DLPFC
#' # dlpfc_data <- process_metrics_and_rename(data, "_DLPFC")
#'
#' # For Hippo
#' # hippo_data <- process_metrics_and_rename(data, "_Hippo")
#'
#' # For Caudate
#' # caudate_data <- process_metrics_and_rename(data, "_Caudate")

process_metrics_and_rename <- function(data, suffix) {
  # Convert the input to a data.table to ensure compatibility
  data <- setDT(data)
  
  # Perform calculations and create new variables
  data[, means_Cl := (C_CTRL + C_SCZ) / 2]
  data[, diffs_Cl := C_CTRL - C_SCZ]
  data[, absDiffs_Cl := abs(diffs_Cl)]
  
  data[, means_kIn := (kIn_CTRL + kIn_SCZ) / 2]
  data[, diffs_kIn := kIn_CTRL - kIn_SCZ]
  data[, absDiffs_kIn := abs(diffs_kIn)]
  
  data[, means_K := (kTotal_CTRL + kTotal_SCZ) / 2]
  data[, diffs_K := kTotal_CTRL - kTotal_SCZ]
  data[, absDiffs_K := abs(diffs_K)]
  
  # Define the names of the new variables to select
  new_vars <- c("means_Cl", "diffs_Cl", "absDiffs_Cl",
                "means_kIn", "diffs_kIn", "absDiffs_kIn",
                "means_K", "diffs_K", "absDiffs_K")
  
  # Check if the variables exist in the data.table
  if (!all(new_vars %in% names(data))) {
    stop("The new variables were not found in the data.table.")
  }
  
  # Create a new data.table with only the selected variables
  result_data <- data[, ..new_vars]
  
  # Rename the columns by adding the suffix
  setnames(result_data, new_vars, paste0(new_vars, suffix))
  
  return(result_data)
}

data<-data1
DLPFC_data<-process_metrics_and_rename(data, "_DLPFC")
DLPFC_data$Symbol<-data$Symbol

# Hippocampus:
data<-data2
Hippo_data<-process_metrics_and_rename(data, "_Hippo")
Hippo_data$Symbol<-data$Symbol

# Caudate:

data<-data3
Caudate_data<-process_metrics_and_rename(data, "_Caudate")
Caudate_data$Symbol<-data$Symbol

# Save the tables to be used for Fig.2

###### Find outliers for differences, mainly absolute differences #######

#### Find outliers for perpendiculars clean with chatGPT ####

base_path <- "/home/edata/For_Cambridge_project_January2023/Robust_WGCNA_gencodeID_v41/"

# 1. Load Libraries: Consolidate and check for duplicates.
# 'data.table' is loaded twice in the original script.
# 'segmented' and 'broom' are loaded but not used in the provided snippet.
# If they are used elsewhere in your full script, keep them. Otherwise, remove.
library(tidyr)
library(dplyr)
library(readxl)
library(data.table) # Already loaded, no need to load again.
# library(broom) # Not used in the provided code
# library(segmented) # Not used in the provided code
library(VennDiagram) # This library is essential for venn.diagram and should be explicitly loaded
library(grid) # Already used in plot generation, good to load explicitly

# 2. Data Loading: Use a list or a consistent naming convention if possible
# If these files are always loaded together, consider a function or list.
# For now, keep as is, but be mindful of their purpose.

data<- list(intramodular_connectivity_DLPFC.xlsx <- read_excel("intramodular_connectivity_DLPFC.xlsx"),
           intraMod_con_refCTRL_modules_12272022.xlsx <- read_excel("Hippocampus/intraMod_con_refCTRL_modules_12272022.xlsx"),
           intraMod_con_refCTRL_modules_01092023.xlsx <- read_excel("Caudate/intraMod_con_refCTRL_modules_01092023.xlsx"))

# The following two are loaded but not used in the provided code.
# If they are not relevant to this script, remove them.


# 3. Initial Data Preparation
# Using `dplyr::mutate` for creating new columns is generally more readable
# and integrates well with the 'tidyverse' philosophy.
data <- data[[3]] %>%
  as.data.table() %>% # Convert to data.table early if using data.table syntax extensively
  mutate(
    kTotal_diff = kTotal_CTRL - kTotal_SCZ,
    kIn_diff = kIn_CTRL - kIn_SCZ,
    C_diff = C_CTRL - C_SCZ,
    abs_col_kTotal=abs(kTotal_CTRL-kTotal_SCZ),
    abs_col_kIn=abs(kIn_CTRL-kIn_SCZ),
    abs_col_C=abs(C_CTRL-C_SCZ))

# 4. Create a Reusable Function for Outlier Analysis and Venn Diagrams
# This is the most significant improvement. It encapsulates the repetitive logic.
perform_outlier_analysis_and_venn <- function(data, abs_col, diff_col, plot_title_abs, plot_title_diff, venn_names, filename_prefix) {
  # Calculate outliers for the absolute measure
  out_abs_values <- boxplot(data[[abs_col]], plot = FALSE)$out # plot = FALSE to suppress plot
  out_abs_data <- data[data[[abs_col]] %in% out_abs_values, ]
  
  # Calculate outliers for the difference measure
  out_diff_values <- boxplot(data[[diff_col]], plot = FALSE)$out
  
  # Separate positive and negative outliers for the difference
  pos_out_diff_values <- out_diff_values[out_diff_values > 0]
  neg_out_diff_values <- out_diff_values[out_diff_values < 0]
  
  pos_out_diff_data <- data[data[[diff_col]] %in% pos_out_diff_values, ]
  neg_out_diff_data <- data[data[[diff_col]] %in% neg_out_diff_values, ]
  
  # Prepare lists of Symbols for Venn Diagram
  venn_lists <- list(
    "Out_abs" = out_abs_data$Symbol,
    "Pos_out_diff" = pos_out_diff_data$Symbol,
    "Neg_out_diff" = neg_out_diff_data$Symbol
  )
  
  # Generate Venn Diagram
  venn_diagram_obj <- venn.diagram(
    x = venn_lists,
    category.names = venn_names,
    filename = NULL, # Render to object for grid.draw
    output = TRUE,
    resolution = 300,
    compression = "lzw",
    lwd = 1,
    col = c('darkred', 'blue', 'darkgreen'),
    fill = c(alpha("sienna1", 0.4), alpha('lightblue', 0.4), alpha('lightgreen', 0.4)),
    cex = 1,
    fontface = "bold",
    fontfamily = "sans",
    cat.cex = 1,
    label.col = 'black',
    label.size = 12,
    cat.default.pos = "outer",
    # cat.pos and cat.dist can be tricky; consider making them arguments if they vary greatly
    cat.pos = c(-27, 27, 135), # Default for kTotal and kIn
    cat.dist = c(0.055, 0.055, 0.085), # Default for kTotal and kIn
    cat.fontfamily = "sans",
    cat.fontface = "bold",
    cat.col = 'black',
    rotation = 1,
    margin = 0.2
  )
  
  # Plot Venn Diagram
  plot.new()
  grid.draw(venn_diagram_obj)
  
  # Return the data frames of outliers if needed for further analysis
  invisible(list(
    out_abs_data = out_abs_data,
    pos_out_diff_data = pos_out_diff_data,
    neg_out_diff_data = neg_out_diff_data,
    venn_lists = venn_lists
  ))
}

# 5. Apply the function for kTotal
kTotal_results <- perform_outlier_analysis_and_venn(
  data = data,
  abs_col = "abs_col_kTotal",
  diff_col = "kTotal_diff",
  plot_title_abs = "Outliers for perpendicular kTotal", # Not directly used in the function, but good for context.
  plot_title_diff = "For positive and negative out kTotal", # Not directly used in the function.
  venn_names = c("Out_kTot_abs", "Pos_out_kTot_diff", "Neg_out_kTot_diff"),
  filename_prefix = "kTotal"
)

# You can access the outlier data frames like this if needed:

kTotal_pos_out_diff <- kTotal_results$pos_out_diff_data
kTotal_neg_out_diff <- kTotal_results$neg_out_diff_data

# Print intersections (now more easily accessible via the returned lists)
# message("\nIntersections for kTotal:")
# message("Positive kTotal_diff and Out_kTotal:")
# kTotal_pos_out_diff_dlpfc<-sort(intersect(kTotal_results$pos_out_diff_data$Symbol, Out_kTotal))
# message("Negative kTotal_diff and Out_kTotal:")
# kTotal_neg_out_diff_dlpfc<-sort(intersect(kTotal_results$neg_out_diff_data$Symbol, Out_kTotal))


# 6. Apply the function for kIn
kIn_results <- perform_outlier_analysis_and_venn(
  data = data,
  abs_col = "abs_col_kIn",
  diff_col = "kIn_diff",
  plot_title_abs = "Outliers for perpendicular kIn/modSize",
  plot_title_diff = "For positive and negative out kIn",
  venn_names = c("Out_kIn_abs", "Pos_out_kIn_diff", "Neg_out_kIn_diff"),
  filename_prefix = "kIn"
)

# message("\nIntersections for kIn_by_modSize:")
# message("Positive kIn_diff and Out_perp_kIn_by_modSize:")
# kIn_pos_out_diff_dlpfc<-sort(intersect(kIn_results$pos_out_diff_data$Symbol, Out_kIn_modSize))
# message("Negative kIn_diff and Out_perp_kIn_by_modSize:")
# kIn_neg_out_diff_dlpfc<-sort(intersect(kIn_results$neg_out_diff_data$Symbol, Out_kIn_modSize))


kIn_pos_out_diff <- kIn_results$pos_out_diff_data
kIn_neg_out_diff <- kIn_results$neg_out_diff_data


# 7. Apply the function for Cl_coeff
# Note: The original code had a typo in the last Venn diagram list (Neg_out_kIn$Symbol instead of Neg_out_C$Symbol).
# This has been corrected here.
Cl_coeff_results <- perform_outlier_analysis_and_venn(
  data = data,
  abs_col = "abs_col_C",
  diff_col = "C_diff",
  plot_title_abs = "Outliers for Clustering coefficient",
  plot_title_diff = "For positive and negative out C",
  venn_names = c("Out_C_abs", "Pos_out_C_diff", "Neg_out_C_diff"),
  filename_prefix = "Cl_coeff"
)

message("\nIntersections for Cl_coeff:")
message("Positive C_diff and Out_Cl_Coeff:")


C_pos_out_diff <- Cl_coeff_results$pos_out_diff_data
C_neg_out_diff <- Cl_coeff_results$neg_out_diff_data

message("\nIsolate abs, and directional: positive and negative outliers overlapped with absolute outliers:")

kTotal_out_abs <- kTotal_results$out_abs_data$Symbol
kTotal_out_abs_pos<-intersect(kTotal_results$venn_lists$Out_abs,kTotal_results$venn_lists$Pos_out_diff)
kTotal_out_abs_neg<-intersect(kTotal_results$venn_lists$Out_abs,kTotal_results$venn_lists$Neg_out_diff)

kIn_out_abs <- kIn_results$out_abs_data$Symbol
kIn_out_abs_pos<-intersect(kIn_results$venn_lists$Out_abs,kIn_results$venn_lists$Pos_out_diff)
kIn_out_abs_neg<-intersect(kIn_results$venn_lists$Out_abs,kIn_results$venn_lists$Neg_out_diff)

C_out_abs <- Cl_coeff_results$out_abs_data$Symbol
C_out_abs_pos<-intersect(Cl_coeff_results$venn_lists$Out_abs,Cl_coeff_results$venn_lists$Pos_out_diff)
C_out_abs_neg<-intersect(Cl_coeff_results$venn_lists$Out_abs,Cl_coeff_results$venn_lists$Neg_out_diff)

# Define common part of file names for cleaner loading
file_prefixes <- c("dlpfc", "hippo", "caudate")
outlier_types <- c("kTotal_out_abs","kTotal_out_abs_pos", "kTotal_out_abs_neg","kIn_out_abs","kIn_out_abs_pos","C_out_abs",
                   "C_out_abs_pos","C_out_abs_neg")

file_prefixes[3]


# --- 1. Define the Function ---
# This function will create and save the outlier list for a given region.
# It assumes that variables like kTotal_out_abs, kTotal_out_abs_pos, etc.,
# corresponding to the *current region being processed*, are available in the
# environment where this function is called, or are passed as arguments.
# For simplicity, I'm assuming they are available globally, as per your snippet.
# If these variables themselves are dynamic or need to be loaded, the function
# would need to handle that.

create_and_save_directional_outliers <- function(region_name_short, date_suffix = "08212025") {
  
  message(paste("Processing outliers for region:", region_name_short))
  
  # Construct the list name dynamically for saving and assignment later
  list_variable_name <- paste0("Out_abs_and_directional_", region_name_short)
  
  # Create an empty list first
  current_region_outlier_list <- list()
  
  # Assign elements using bracket notation for dynamic naming
  # IMPORTANT: The variables like kTotal_out_abs, kTotal_out_abs_neg, etc.
  # MUST be defined and contain the correct data for the current region
  # (e.g., for 'dlpfc', kTotal_out_abs should contain DLPFC-specific data)
  # *before* this function is called for that region.
  current_region_outlier_list[[paste0("kTotal_abs_", region_name_short)]] <- kTotal_out_abs
  current_region_outlier_list[[paste0("kTotal_neg_", region_name_short)]] <- kTotal_out_abs_neg
  current_region_outlier_list[[paste0("kTotal_pos_", region_name_short)]] <- kTotal_out_abs_pos
  current_region_outlier_list[[paste0("C_abs_", region_name_short)]] <- C_out_abs
  current_region_outlier_list[[paste0("C_pos_", region_name_short)]] <- C_out_abs_pos
  current_region_outlier_list[[paste0("C_neg_", region_name_short)]] <- C_out_abs_neg
  current_region_outlier_list[[paste0("kIn_abs_", region_name_short)]] <- kIn_out_abs
  current_region_outlier_list[[paste0("kIn_pos_", region_name_short)]] <- kIn_out_abs_pos
  current_region_outlier_list[[paste0("kIn_neg_", region_name_short)]] <- kIn_out_abs_neg
  
  # Assign the created list to a dynamic variable name in the calling environment
  # This makes it accessible after the function call, e.g., Out_abs_and_directional_dlpfc
  assign(list_variable_name, current_region_outlier_list, envir = .GlobalEnv)
  
  # Construct the output filename
  output_filename <- paste0("Outliers_abs_and_directional_", region_name_short, "_", date_suffix, ".RData")
  
  # Save the list. We save the dynamically created list by its name.
  save(list = list_variable_name, file = output_filename)
  
  message(paste("Saved", list_variable_name, "to", output_filename))
}

# Call for DLPFC
create_and_save_directional_outliers(file_prefixes[3]) # "dlpfc","hippo","caudate"







